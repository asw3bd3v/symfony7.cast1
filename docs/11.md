# Fancier Routes: Requirements, Wildcards, and More

Со всей новой организацией кода давайте отпразднуем это, создав еще одну конечную точку API для извлечения одного звездолета. Начнем как обычно: создадим публичную функцию с именем, как насчет get(). Я включу необязательный тип возвращаемого значения Response. Выше этого добавьте #[Route] с URL-адресом /api/starships/... хм. На этот раз последняя часть URL-адреса должна быть динамической: она должна соответствовать /api/starships/5 или /api/starships/25. Как это сделать? Как сделать так, чтобы маршрут соответствовал подстановочному знаку?

Ответ — добавить {, имя, }.

Имя внутри этого может быть любым. Независимо от того, что именно, этот маршрут теперь будет соответствовать /api/starships/\*. Но как бы вы это ни назвали, теперь вам разрешено иметь аргумент с соответствующим именем: $id.

Ниже приведен дамп, чтобы убедиться, что он работает.

```php
class StarshipApiController extends AbstractController
{

    #[Route('/api/starships/{id}')]
    public function get($id): Response
    {
        dd($id);
    }
}
```

## Restricting the Wildcard to be a Number / Ограничение подстановочного знака числом

Перейдите к /api/starships/2 и... это работает!

В нашем приложении идентификатор будет целым числом. Если я попробую что-то, что не является целым числом, например /wharf, маршрут все равно совпадет и вызовет наш контроллер. И это почти всегда нормально. В реальном приложении, если мы запросим базу данных с WHERE ID = 'wharf', это не вызовет ошибку: оно просто не найдет соответствующий корабль! И тогда мы можем вызвать страницу 404, которую я покажу вам скоро.

Но иногда мы можем захотеть ограничить эти значения.

Для этого внутри фигурных скобок после имени добавьте <, >, а внутри — регулярное выражение \d+.

Это означает: сопоставьте цифру любой длины. При такой настройке, если мы обновим URL, мы получим ошибку 404. Наш маршрут просто не сопоставился — ни один маршрут не сопоставился — поэтому наш контроллер никогда не вызывался. Но если мы вернемся к /2, это все еще работает.

И в качестве дополнительного преимущества, теперь, когда это соответствует только цифрам, мы можем добавить тип int к аргументу. Теперь вместо строки 2 мы получаем целое число 2. Эти детали не очень важны, но я хочу, чтобы вы знали, какие у вас есть варианты.

## Restricting the Route HTTP Method / Ограничение метода HTTP маршрута

Одна из общих черт API — создание маршрутов, соответствующих только определенному HTTP-методу, например GET или POST. Например, если вы хотите получить все звездолеты, пользователи должны сделать запрос GET... то же самое, если вы хотите получить один корабль. Если бы мы продолжили разрабатывать наш API и создали конечную точку, которую можно было бы использовать для создания нового звездолета, стандартным способом сделать это было бы использование того же URL: /api/starships, но с запросом POST.

Сейчас это не сработает. Каждый раз, когда пользователь запрашивал /api/starships — неважно, использовал ли он запрос GET или POST, он соответствовал этому первому маршруту.

По этой причине в API принято добавлять набор опций методов к массиву с помощью GET или POST. Я сделаю то же самое здесь: methods: ['GET'].

```php
class StarshipApiController extends AbstractController
{
    #[Route('/api/starships', methods: ['GET'])]
    public function getCollection(StarshipRepository $repository): Response
// ... lines 14 - 19
    #[Route('/api/starships/{id<\d+>}', methods: ['GET'])]
    public function get(int $id): Response
// ... lines 22 - 24
}
```

Я не могу легко проверить это в браузере, но если бы мы сделали POST-запрос к /api/starships/2, он не соответствовал бы нашему маршруту.

Но мы можем увидеть изменения в нашем терминале. Запустите:

```
php bin/console debug:router
```

Большинство маршрутов соответствуют любому методу... но наши два маршрута API соответствуют только в том случае, если на этот URL-адрес отправляется запрос GET.

## Prefixing Every Route URL / Добавление префикса к каждому URL-адресу маршрута

Каждый маршрут в этом контроллере начинается с одного и того же URL: /api/starships. Наличие полного URL в каждом маршруте нормально. Но если мы хотим, мы можем автоматически добавлять префикс к URL каждого маршрута. Над классом добавьте атрибут #[Route] с /api/starships.

В отличие от того, когда мы помещаем это выше метода, это не создает маршрут. Он просто говорит: каждый маршрут в этом классе должен иметь префикс с этим URL. Поэтому для первого маршрута полностью удалите путь. А для второго нам нужна только часть с подстановочным знаком.

```php
#[Route('/api/starships')]
class StarshipApiController extends AbstractController
{
    #[Route('', methods: ['GET'])]
    public function getCollection(StarshipRepository $repository): Response
// ... lines 15 - 20
    #[Route('/{id<\d+>}', methods: ['GET'])]
    public function get(int $id): Response
// ... lines 23 - 25
}
```

Попробуйте debug:router еще раз... и посмотрите эти URL-адреса:

```
php bin/console debug:router
```

Они не меняются!

## Finishing the new API Endpoint / Завершение новой конечной точки API

Давайте закончим нашу конечную точку. Нам нужно найти один корабль, который соответствует этому идентификатору. Обычно мы делаем запрос к базе данных: select \* from ship where id = this ID. Наши корабли сейчас жестко закодированы, но мы все еще можем сделать что-то, что будет выглядеть почти так же, как и будет, когда у нас будет база данных.

У нас уже есть служба - StarshipRepository - вся работа которой заключается в извлечении данных о звездолетах. Давайте дадим ей новую суперспособность: возможность извлекать один Starship для идентификатора. Добавьте публичную функцию find() с аргументом int $id, которая вернет Starship, допускающий значение null. Итак, Starship, если мы найдем его для этого идентификатора, в противном случае null.

Прямо сейчас, самый простой способ написать эту логику — это цикл по $this->findAll() как $starship... затем, если $starship->getId() === $id, вернуть $starship. Я изменю свой uf на if. Намного лучше.

А если ничего не нашли, то внизу возвращаем null.

```php
class StarshipRepository
{
// ... lines 10 - 42
    public function find(int $id): ?Starship
    {
        foreach ($this->findAll() as $starship) {
            if ($starship->getId() === $id) {
                return $starship;
            }
        }
        return null;
    }
}
```

Благодаря этому наш контроллер настолько прост. Сначала автопривяжите репозиторий, добавив аргумент: StarshipRepository и просто назовите его $repository. Кстати, порядок аргументов в контроллере не имеет значения.

```php
class StarshipApiController extends AbstractController
{
// ... lines 13 - 21
    public function get(int $id, StarshipRepository $repository): Response
    {
        $starship = $repository->find($id);
        return $this->json($starship);
    }
}
```

## Triggering a 404 Page / Вызов страницы 404

Но попробуйте идентификатор, которого нет в нашей поддельной базе данных - например, /200. Слово null - это... не то, что нам нужно. В этой ситуации мы должны вернуть ответ с кодом статуса 404.

Чтобы сделать это, мы собираемся следовать общему шаблону: запросить объект, затем проверить, вернул ли он что-нибудь. Если он ничего не вернул, вызвать 404. Сделайте это с помощью throw $this->createNotFoundException().

```php
class StarshipApiController extends AbstractController
{
// ... lines 13 - 21
    public function get(int $id, StarshipRepository $repository): Response
    {
        $starship = $repository->find($id);
        if (!$starship) {
            throw $this->createNotFoundException('Starship not found');
        }
        return $this->json($starship);
    }
}
```

Обратите внимание на ключевое слово throw: мы создаем особое исключение, которое вызывает ошибку 404. Это хорошо, потому что как только оно попадет на эту строку, ничего после этого выполняться не будет.

Далее: давайте создадим HTML-версию этой страницы, страницу, которая показывает подробности об одном звездолете. Затем мы научимся связывать страницы, используя имя маршрута.