# Services: The Backbone of Everything

Давайте поговорим о сервисах. Это самая важная концепция в Symfony. И как только вы их поймете, честно говоря, вы сможете делать все, что угодно.

## What is a Service?

Во-первых, сервис — это объект, который работает. Вот и всё. Например, если вы создали экземпляр объекта Logger, у которого есть метод log(), это сервис! Он работает: он регистрирует события! Или если вы создали объект подключения к базе данных, который делает запросы к базе данных, то... да! Это тоже сервис.

Итак... если сервис — это просто объект, который работает... какие ленивые объекты не являются сервисми? Наш класс Starship — прекрасный пример не-сервиса. Его главная задача — не выполнять работу: он должен хранить данные. Конечно, у него есть несколько открытых методов... и вы даже можете поместить внутрь этих методов некоторую логику, чтобы что-то делать. Но в конечном итоге это не работник, а держатель данных.

А что насчет классов контроллеров? Да, они тоже сервисы. Их работа — создавать объекты ответа.

В любом случае, каждая часть работы, которая выполняется в Symfony, на самом деле выполняется службой. Запись сообщений журнала в этот файл? Да, для этого есть сервис. Выяснение того, какой маршрут соответствует текущему URL? Это сервис маршрутизатора! А как насчет рендеринга шаблона twig? Да, оказывается, что метод render() — это ярлык для поиска правильного объекта сервиса и вызова метода для него.

## The Container & debug:container

Иногда вы также можете слышать, что эти службы организованы в большой объект, называемый «контейнером служб» ("service container"). Вы можете думать о контейнере как о гигантском ассоциативном массиве объектов служб, каждый из которых имеет уникальный идентификатор. Хотите увидеть список всех служб в нашем приложении прямо сейчас? Я тоже!

```
php bin/console debug:container
```

Слева мы видим ID каждой службы. А справа — класс объекта, которому соответствует ID.

Вернитесь к нашему контроллеру и удерживайте control или command, чтобы снова открыть метод json(). Теперь это имеет больше смысла! Он проверяет, есть ли у контейнера служба с идентификатором serializer. Если есть, он извлекает эту службу из контейнера и вызывает для нее метод serialize().

Когда мы работаем с сервисами, это не будет выглядеть именно так. Но самое главное, что теперь мы понимаем, что происходит.

## Bundles Provide Services / Пакеты предоставляющие сервисы

Мой следующий вопрос: откуда берутся эти сервисы? Например, кто сказал, что есть сервис с идентификатором twig... и что когда мы запрашиваем его у контейнера, он должен возвращать объект twig Environment? Ответ: полностью из пакетов. На самом деле, это и есть главный смысл установки нового пакета. Пакеты предоставляют нам сервисы.

## Autowiring

И хотя в этом списке много сервисов, подавляющее большинство из них — низкоуровневые объекты сервисов, которые мы никогда не будем использовать или о которых не будем заботиться. Мы также не будем заботиться об идентификаторах сервисов большую часть времени.

Вместо этого выполните связанную команду:

```
php bin/console debug:autowiring
```

Это показывает нам все сервисы, которые являются автоподключаемыми, что является техникой, которую мы будем использовать для извлечения сервисов. Это в основном курируемый список сервисов, которые нам, скорее всего, понадобятся.

## Autowiring the Logger Service

Суть в том, что если мы хотим что-то записать в журнал, нам просто нужно найти службу, которая это делает. Хорошо! Повторно выполните команду, но выполните поиск по слову log:

```
php bin/console debug:autowiring log
```

Получим следующее.

```
Autowirable Types
=================

 The following classes & interfaces can be used as type-hints when autowiring:
 (only showing classes/interfaces matching log)

 Describes a logger instance.
 Psr\Log\LoggerInterface - alias:monolog.logger
 Psr\Log\LoggerInterface $cacheLogger - alias:monolog.logger.cache
 Psr\Log\LoggerInterface $consoleLogger - alias:monolog.logger.console
 Psr\Log\LoggerInterface $debugLogger - alias:monolog.logger.debug
 Psr\Log\LoggerInterface $deprecationLogger - alias:monolog.logger.deprecation
 Psr\Log\LoggerInterface $eventLogger - alias:monolog.logger.event
 Psr\Log\LoggerInterface $phpLogger - alias:monolog.logger.php
 Psr\Log\LoggerInterface $profilerLogger - alias:monolog.logger.profiler
 Psr\Log\LoggerInterface $requestLogger - alias:monolog.logger.request
 Psr\Log\LoggerInterface $routerLogger - alias:monolog.logger.router
 ```

Он нашел около 10 сервисов, все начинаются с Psr\Log\LoggerInterface. Мы поговорим о том, что это за другие сервисы, в следующем уроке. А пока сосредоточимся на главной. Это говорит мне о том, что в контейнере есть сервис для длогера. И чтобы получить ее, мы можем автоматически подключить ее с помощью этого интерфейса.

Что это значит? В методе контроллера, где нам нужен логгер, добавьте аргумент с указанием типа LoggerInterface.

```php
// src/Controller/StarshipApiController.php
use Psr\Log\LoggerInterface;

class StarshipApiController extends AbstractController
{

    public function getCollection(LoggerInterface $logger): Response
    {

    }
}
```

В этом случае имя аргумента не имеет значения: это может быть что угодно. Важно то, что LoggerInterface, который соответствует этому оператору use, совпадает с Psr\Log\LoggerInterface из debug:autowiring.

Symfony передает нам объект Monolog\Logger, который реализует этот LoggerInterface.

Трюк, который мы только что проделали — называемый автосвязыванием (autowiring) — работает ровно в двух местах: наши методы контроллера и метод __construct() любой службы. Мы увидим вторую ситуацию в следующей главе.

## Controlling how Services Behave / Контроль поведения служб

И если вам интересно, откуда вообще взялась эта служба Logger... мы уже знаем ответ! Из пакета. В данном случае MonologBundle. И... как мы можем настроить эту службу... чтобы, я не знаю, регистрировать в другом файле? Ответ: config/packages/monolog.yaml.

```yaml
path: "%kernel.logs_dir%/%kernel.environment%.log"
```

Эта конфигурация, включая эту строку, настраивает MonologBundle... что на самом деле означает, что она настраивает работу служб, которые предоставляет нам MonologBundle. Мы узнаем об этом синтаксисе процентов в следующем уроке, но это говорит службе Logger вести журнал в этом файле dev.log.

## Using the Logger / Использование логера

Хорошо, теперь, когда у нас есть служба Logger, давайте ее использовать! Как? Ну, конечно, вы можете прочитать документацию. Но благодаря подсказке типа, наш редактор нам поможет! У LoggerInterface есть куча методов. Давайте используем ->info() и скажем:

```php
// src/Controller/StarshipApiController.php
use Psr\Log\LoggerInterface;

class StarshipApiController extends AbstractController
{
    public function getCollection(LoggerInterface $logger): Response
    {
        $logger->info('Starship collection retrieved');
    }
}
```

Попробуйте: обновить. Страница заработала... но записала ли она что-нибудь в журнал? Мы можем проверить файл dev.log. Или мы можем использовать раздел Log профайлера для этого запроса.

## Seeing the Profiler for an API Request / Просмотр профилировщика для запроса API

Но... подождите! Это запрос API... так что у нас нет этой крутой панели инструментов веб-отладки внизу! Это правда... но Symfony все равно собрал всю эту информацию! Чтобы получить доступ к профайлеру для этого запроса, измените URL на /_profiler. Это перечислит самые последние запросы к нашему приложению, с самым новым наверху. Видите это? Это наш запрос API минуту назад! Если вы нажмете на этот токен... бум! Мы смотрим на профайлер для этого вызова API во всей его красе... включая раздел журнала... с нашим сообщением.